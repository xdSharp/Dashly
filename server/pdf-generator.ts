import PDFDocument from 'pdfkit';
import { Sale, User, Product, Category } from '@shared/schema';
import { storage } from './storage';
import { Stream } from 'stream';

interface ChartData {
  labels: string[];
  datasets: {
    label: string;
    data: number[];
  }[];
}

interface ReportOptions {
  title: string;
  userId: number;
  filters: {
    startDate?: Date;
    endDate?: Date;
    categoryId?: number;
    productId?: number;
    employee?: string;
  };
  charts: {
    revenue?: ChartData;
    categories?: ChartData;
    products?: ChartData;
  };
}

export async function generatePDF(options: ReportOptions, outputStream: Stream): Promise<void> {
  const doc = new PDFDocument({ margin: 50 });
  doc.pipe(outputStream);
  
  try {
    // Generate report content
    await generateReportContent(doc, options);
    doc.end();
  } catch (error) {
    // In case of error, end the document and rethrow
    doc.end();
    throw error;
  }
}

async function generateReportContent(doc: PDFKit.PDFDocument, options: ReportOptions): Promise<void> {
  const { title, userId, filters } = options;
  
  // Get user data
  const user = await storage.getUser(userId);
  if (!user) {
    throw new Error('User not found');
  }
  
  // Get sales data with filters
  const allSales = await storage.getAllSales(userId);
  
  // Apply filters
  const filteredSales = allSales.filter(sale => {
    let match = true;
    
    if (filters.startDate) {
      match = match && sale.date >= filters.startDate;
    }
    
    if (filters.endDate) {
      match = match && sale.date <= filters.endDate;
    }
    
    if (filters.employee) {
      match = match && sale.employee === filters.employee;
    }
    
    return match;
  });
  
  // Header with logo and title
  addHeader(doc, title);
  
  // Report metadata
  addMetadata(doc, user, filters);
  
  // Summary statistics
  addSummaryStatistics(doc, filteredSales);
  
  // Add charts (if provided)
  if (options.charts.revenue) {
    addChartSection(doc, 'Revenue Over Time', options.charts.revenue);
  }
  
  if (options.charts.categories) {
    addChartSection(doc, 'Sales by Category', options.charts.categories);
  }
  
  if (options.charts.products) {
    addChartSection(doc, 'Top Products', options.charts.products);
  }
  
  // Sales data table
  await addSalesTable(doc, filteredSales);
}

function addHeader(doc: PDFKit.PDFDocument, title: string): void {
  // Logo placeholder
  doc.fontSize(10).text('SalesVue', { align: 'left' });
  
  // Report title
  doc.moveDown(1);
  doc.fontSize(18).font('Helvetica-Bold').text(title, { align: 'center' });
  doc.moveDown(1);
}

function addMetadata(doc: PDFKit.PDFDocument, user: User, filters: ReportOptions['filters']): void {
  doc.fontSize(10).font('Helvetica');
  
  // User and date info
  doc.text(`Generated by: ${user.name}`, { continued: true })
    .text(`Date: ${new Date().toLocaleDateString()}`, { align: 'right' });
  
  // Filters applied
  doc.moveDown(0.5);
  doc.text('Filters applied:', { underline: true });
  
  doc.moveDown(0.5);
  doc.text(`Date range: ${
    filters.startDate && filters.endDate 
      ? `${filters.startDate.toLocaleDateString()} to ${filters.endDate.toLocaleDateString()}`
      : 'All time'
  }`);
  
  if (filters.employee) {
    doc.text(`Employee: ${filters.employee}`);
  }
  
  doc.moveDown(1);
  doc.moveTo(50, doc.y).lineTo(doc.page.width - 50, doc.y).stroke();
  doc.moveDown(1);
}

function addSummaryStatistics(doc: PDFKit.PDFDocument, sales: Sale[]): void {
  doc.fontSize(14).font('Helvetica-Bold').text('Summary', { underline: true });
  doc.moveDown(0.5).fontSize(10).font('Helvetica');
  
  // Calculate statistics
  const totalSales = sales.length;
  const totalRevenue = sales.reduce((sum, sale) => sum + Number(sale.amount), 0);
  const totalQuantity = sales.reduce((sum, sale) => sum + sale.quantity, 0);
  const averageOrderValue = totalSales > 0 ? totalRevenue / totalSales : 0;
  
  // Display statistics in a grid
  doc.text(`Total Sales: ${totalSales}`, { width: 200, continued: true })
    .text(`Total Revenue: $${totalRevenue.toFixed(2)}`, { align: 'right' });
  
  doc.moveDown(0.5);
  doc.text(`Total Items Sold: ${totalQuantity}`, { width: 200, continued: true })
    .text(`Average Order Value: $${averageOrderValue.toFixed(2)}`, { align: 'right' });
  
  doc.moveDown(1);
  doc.moveTo(50, doc.y).lineTo(doc.page.width - 50, doc.y).stroke();
  doc.moveDown(1);
}

function addChartSection(doc: PDFKit.PDFDocument, title: string, chartData: ChartData): void {
  doc.fontSize(14).font('Helvetica-Bold').text(title, { underline: true });
  doc.moveDown(0.5).fontSize(10).font('Helvetica');
  
  // Since we can't actually render charts in PDFKit directly, we'll add a text representation
  doc.text('Chart data representation:');
  doc.moveDown(0.5);
  
  // Create a simple text representation of the chart data
  chartData.labels.forEach((label, i) => {
    const dataValue = chartData.datasets[0].data[i] || 0;
    doc.text(`${label}: ${dataValue}`);
  });
  
  doc.moveDown(1);
}

async function addSalesTable(doc: PDFKit.PDFDocument, sales: Sale[]): Promise<void> {
  doc.fontSize(14).font('Helvetica-Bold').text('Sales Data', { underline: true });
  doc.moveDown(0.5);
  
  // Set up table
  const tableTop = doc.y;
  const tableColumnWidth = (doc.page.width - 100) / 6;
  
  // Table headers
  doc.fontSize(10).font('Helvetica-Bold');
  doc.text('Product', 50, tableTop, { width: tableColumnWidth, align: 'left' });
  doc.text('Category', 50 + tableColumnWidth, tableTop, { width: tableColumnWidth, align: 'left' });
  doc.text('Price', 50 + tableColumnWidth * 2, tableTop, { width: tableColumnWidth, align: 'right' });
  doc.text('Quantity', 50 + tableColumnWidth * 3, tableTop, { width: tableColumnWidth, align: 'right' });
  doc.text('Amount', 50 + tableColumnWidth * 4, tableTop, { width: tableColumnWidth, align: 'right' });
  doc.text('Date', 50 + tableColumnWidth * 5, tableTop, { width: tableColumnWidth, align: 'left' });
  
  // Draw header line
  doc.moveTo(50, tableTop + 15).lineTo(doc.page.width - 50, tableTop + 15).stroke();
  
  // Table rows
  doc.fontSize(10).font('Helvetica');
  let rowTop = tableTop + 25;
  
  // Load additional data for products and categories
  const products = new Map();
  const categories = new Map();
  
  for (const sale of sales) {
    // Get product if not in cache
    if (!products.has(sale.productId)) {
      const product = await storage.getProduct(sale.productId);
      products.set(sale.productId, product);
    }
    
    const product = products.get(sale.productId);
    if (!product) continue;
    
    // Get category if not in cache
    if (!categories.has(product.categoryId)) {
      const category = await storage.getCategory(product.categoryId);
      categories.set(product.categoryId, category);
    }
    
    const category = categories.get(product.categoryId);
    if (!category) continue;
    
    // Check if we need a new page
    if (rowTop > doc.page.height - 70) {
      doc.addPage();
      rowTop = 50;
      
      // Add headers to new page
      doc.fontSize(10).font('Helvetica-Bold');
      doc.text('Product', 50, rowTop, { width: tableColumnWidth, align: 'left' });
      doc.text('Category', 50 + tableColumnWidth, rowTop, { width: tableColumnWidth, align: 'left' });
      doc.text('Price', 50 + tableColumnWidth * 2, rowTop, { width: tableColumnWidth, align: 'right' });
      doc.text('Quantity', 50 + tableColumnWidth * 3, rowTop, { width: tableColumnWidth, align: 'right' });
      doc.text('Amount', 50 + tableColumnWidth * 4, rowTop, { width: tableColumnWidth, align: 'right' });
      doc.text('Date', 50 + tableColumnWidth * 5, rowTop, { width: tableColumnWidth, align: 'left' });
      
      doc.moveTo(50, rowTop + 15).lineTo(doc.page.width - 50, rowTop + 15).stroke();
      rowTop += 25;
      doc.fontSize(10).font('Helvetica');
    }
    
    // Format date
    const formattedDate = sale.date.toLocaleDateString();
    
    // Add row data
    doc.text(product.name, 50, rowTop, { width: tableColumnWidth, align: 'left' });
    doc.text(category.name, 50 + tableColumnWidth, rowTop, { width: tableColumnWidth, align: 'left' });
    doc.text(`$${Number(sale.price).toFixed(2)}`, 50 + tableColumnWidth * 2, rowTop, { width: tableColumnWidth, align: 'right' });
    doc.text(sale.quantity.toString(), 50 + tableColumnWidth * 3, rowTop, { width: tableColumnWidth, align: 'right' });
    doc.text(`$${Number(sale.amount).toFixed(2)}`, 50 + tableColumnWidth * 4, rowTop, { width: tableColumnWidth, align: 'right' });
    doc.text(formattedDate, 50 + tableColumnWidth * 5, rowTop, { width: tableColumnWidth, align: 'left' });
    
    rowTop += 20;
  }
  
  // Draw final line
  doc.moveTo(50, rowTop).lineTo(doc.page.width - 50, rowTop).stroke();
}
