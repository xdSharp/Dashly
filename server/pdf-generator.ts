import PDFDocument from 'pdfkit';
import { format } from 'date-fns';
import { enUS, ru } from 'date-fns/locale';
import * as path from 'path';
import * as fs from 'fs';
import { fileURLToPath } from 'url';

// Получаем правильный путь в ES модулях
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Путь к файлу шрифта
const ROBOTO_FONT_PATH = path.join(__dirname, '..', 'assets', 'fonts', 'Roboto-Regular.ttf');

// Проверка наличия шрифта
function validateFont(): string {
  if (!fs.existsSync(ROBOTO_FONT_PATH)) {
    throw new Error('Шрифт не найден. Проверьте наличие файла Roboto-Regular.ttf в директории assets/fonts');
  }
  return ROBOTO_FONT_PATH;
}

/**
 * Определяет язык контента на основе наличия кириллицы
 * @param text Текст для проверки
 * @returns true если содержит кириллицу
 */
function containsCyrillic(text: string): boolean {
  return /[а-яА-ЯёЁ]/.test(text);
}

/**
 * Генерирует PDF отчет на основе предоставленных данных
 * @param data Данные отчета
 * @param dateRange Диапазон дат
 * @param user Информация о пользователе
 * @returns Buffer с PDF документом
 */
export async function generatePDF(data: any, dateRange: any, user: any): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    try {
      // Проверяем наличие шрифта перед генерацией
      const fontPath = validateFont();
      
      // Определяем язык на основе данных пользователя или названий продуктов
      const language = containsCyrillic(user.name || '') || 
                      (data.sales && data.sales.length > 0 && 
                       containsCyrillic(data.sales[0].productName || '')) ? 'ru' : 'en';
      
      // Устанавливаем локаль для форматирования дат
      const dateLocale = language === 'ru' ? ru : enUS;
      
      // Переводы для разных языков
      const translations = {
        en: {
          salesReport: 'Sales Report',
          creationDate: 'Creation date',
          user: 'User',
          reportPeriod: 'Report period',
          from: 'from',
          to: 'to',
          sales: 'SALES',
          no: 'No.',
          product: 'Product',
          qty: 'Qty',
          price: 'Price',
          amount: 'Amount',
          date: 'Date',
          status: 'Status',
          totalSalesAmount: 'Total sales amount',
          popularProducts: 'POPULAR PRODUCTS',
          category: 'Category',
          sold: 'Sold',
          revenue: 'Revenue',
          footer: '* Document automatically generated by Dashly system'
        },
        ru: {
          salesReport: 'Отчет о продажах',
          creationDate: 'Дата создания',
          user: 'Пользователь',
          reportPeriod: 'Период отчета',
          from: 'с',
          to: 'по',
          sales: 'ПРОДАЖИ',
          no: '№',
          product: 'Товар',
          qty: 'Кол-во',
          price: 'Цена',
          amount: 'Сумма',
          date: 'Дата',
          status: 'Статус',
          totalSalesAmount: 'Общая сумма продаж',
          popularProducts: 'ПОПУЛЯРНЫЕ ТОВАРЫ',
          category: 'Категория',
          sold: 'Продано',
          revenue: 'Выручка',
          footer: '* Документ автоматически сгенерирован системой Dashly'
        }
      };
      
      const t = translations[language];

      // Создаем новый PDF документ с базовыми настройками
      const doc = new PDFDocument({
        size: 'A4',
        margin: 50,
        info: {
          Title: language === 'ru' ? 'Отчет о продажах Dashly' : 'Dashly Sales Report',
          Author: user.name || 'Dashly User',
          Subject: language === 'ru' ? 'Отчет о бизнес-активности' : 'Business Activity Report',
          Keywords: language === 'ru' ? 'продажи, товары, категории, доход' : 'sales, products, categories, revenue',
          CreationDate: new Date()
        },
        autoFirstPage: true,
        bufferPages: true
      });

      // Регистрируем шрифт Roboto для поддержки кириллицы
      doc.registerFont('Roboto', fontPath);
      doc.font('Roboto');
      
      // Буфер для данных PDF
      const buffers: Buffer[] = [];
      doc.on('data', buffers.push.bind(buffers));
      doc.on('end', () => {
        const pdfData = Buffer.concat(buffers);
        resolve(pdfData);
      });

      // === СОЗДАНИЕ ОТЧЕТА С ПРАВИЛЬНЫМ ФОРМАТИРОВАНИЕМ ===
      
      // Заголовок отчета
      doc.fontSize(18).text('DASHLY', { align: 'center' })
         .fontSize(14).text(t.salesReport, { align: 'center' })
         .moveDown();
      
      // Информация об отчете
      const now = new Date();
      const dateFormat = language === 'ru' ? 'dd.MM.yyyy' : 'MM/dd/yyyy';
      
      doc.fontSize(10)
         .text(`${t.creationDate}: ${format(now, dateFormat, { locale: dateLocale })}`)
         .text(`${t.user}: ${user.name || 'Not specified'}`)
         .moveDown();
      
      // Период отчета
      if (dateRange && (dateRange.from || dateRange.to)) {
        let periodText = `${t.reportPeriod}: `;
        
        if (dateRange.from && dateRange.to) {
          periodText += `${t.from} ${format(new Date(dateRange.from), dateFormat, { locale: dateLocale })} ${t.to} ${format(new Date(dateRange.to), dateFormat, { locale: dateLocale })}`;
        } else if (dateRange.from) {
          periodText += `${t.from} ${format(new Date(dateRange.from), dateFormat, { locale: dateLocale })}`;
        } else if (dateRange.to) {
          periodText += `${t.to} ${format(new Date(dateRange.to), dateFormat, { locale: dateLocale })}`;
        }
        
        doc.text(periodText).moveDown();
      }
      
      // Горизонтальная линия
      doc.moveTo(50, doc.y)
         .lineTo(doc.page.width - 50, doc.y)
         .stroke()
         .moveDown();
      
      // Информация о продажах
      if (data.sales && data.sales.length > 0) {
        let totalAmount = 0;
        
        doc.fontSize(12).text(t.sales, { underline: true }).moveDown(0.5);
        
        // Используем простую табличную разметку с фиксированными колонками
        const tableTop = doc.y;
        const tableLeft = 50;
        const colWidths = {
          no: 30,
          product: 120,
          qty: 40,
          price: 60,
          amount: 70,
          date: 70,
          status: 90
        };
        
        // Заголовки таблицы
        doc.fontSize(9);
        doc.text(t.no, tableLeft, tableTop);
        doc.text(t.product, tableLeft + colWidths.no, tableTop);
        doc.text(t.qty, tableLeft + colWidths.no + colWidths.product, tableTop);
        doc.text(t.price, tableLeft + colWidths.no + colWidths.product + colWidths.qty, tableTop);
        doc.text(t.amount, tableLeft + colWidths.no + colWidths.product + colWidths.qty + colWidths.price, tableTop);
        doc.text(t.date, tableLeft + colWidths.no + colWidths.product + colWidths.qty + colWidths.price + colWidths.amount, tableTop);
        doc.text(t.status, tableLeft + colWidths.no + colWidths.product + colWidths.qty + colWidths.price + colWidths.amount + colWidths.date, tableTop);
        
        // Линия после заголовков
        doc.moveDown();
        const headerLineY = doc.y;
        doc.moveTo(tableLeft, headerLineY)
           .lineTo(tableLeft + colWidths.no + colWidths.product + colWidths.qty + colWidths.price + colWidths.amount + colWidths.date + colWidths.status, headerLineY)
           .stroke();
        doc.moveDown(0.5);
        
        // Строки таблицы
        data.sales.forEach((sale: any, i: number) => {
          const rowTop = doc.y;
          const num = (i + 1).toString();
          const productName = sale.productName || t.product;
          const quantity = (sale.quantity || '0').toString();
          const price = (sale.price ? `${parseFloat(sale.price).toFixed(2)} ₽` : '0.00 ₽');
          const amount = (sale.totalAmount ? `${parseFloat(sale.totalAmount).toFixed(2)} ₽` : '0.00 ₽');
          
          // Форматируем дату в зависимости от языка
          const dateFormat = language === 'ru' ? 'dd.MM.yy' : 'MM/dd/yy';
          const date = format(new Date(sale.saleDate || now), dateFormat, { locale: dateLocale });
          
          // Переводим статус если нужно
          let status = sale.status || 'Completed';
          if (language === 'ru' && status === 'Completed') {
            status = 'Завершено';
          }
          
          // Добавляем к общей сумме
          totalAmount += parseFloat(sale.totalAmount || 0);
          
          // Печатаем каждую ячейку в фиксированных позициях
          doc.text(num, tableLeft, rowTop);
          doc.text(productName, tableLeft + colWidths.no, rowTop, { width: colWidths.product - 5 });
          doc.text(quantity, tableLeft + colWidths.no + colWidths.product, rowTop);
          doc.text(price, tableLeft + colWidths.no + colWidths.product + colWidths.qty, rowTop);
          doc.text(amount, tableLeft + colWidths.no + colWidths.product + colWidths.qty + colWidths.price, rowTop);
          doc.text(date, tableLeft + colWidths.no + colWidths.product + colWidths.qty + colWidths.price + colWidths.amount, rowTop);
          doc.text(status, tableLeft + colWidths.no + colWidths.product + colWidths.qty + colWidths.price + colWidths.amount + colWidths.date, rowTop);
          
          // Вычисляем высоту, необходимую для этой строки
          const textHeight = Math.max(doc.heightOfString(productName, { width: colWidths.product - 5 }), 12);
          doc.moveDown(textHeight / 12);
        });
        
        doc.moveDown()
           .text(`${t.totalSalesAmount}: ${totalAmount.toFixed(2)} ₽`, { align: 'right' })
           .moveDown();
      }
      
      // Добавляем новую страницу если недостаточно места
      if (doc.y > doc.page.height - 200 && data.products && data.products.length > 0) {
        doc.addPage();
      }
      
      // Информация о продуктах
      if (data.products && data.products.length > 0) {
        doc.fontSize(12).text(t.popularProducts, { underline: true }).moveDown(0.5);
        
        // Используем простую табличную разметку с фиксированными колонками
        const tableTop = doc.y;
        const tableLeft = 50;
        const colWidths = {
          no: 30,
          product: 120,
          category: 120,
          sold: 50,
          revenue: 80
        };
        
        // Заголовки таблицы
        doc.fontSize(9);
        doc.text(t.no, tableLeft, tableTop);
        doc.text(t.product, tableLeft + colWidths.no, tableTop);
        doc.text(t.category, tableLeft + colWidths.no + colWidths.product, tableTop);
        doc.text(t.sold, tableLeft + colWidths.no + colWidths.product + colWidths.category, tableTop);
        doc.text(t.revenue, tableLeft + colWidths.no + colWidths.product + colWidths.category + colWidths.sold, tableTop);
        
        // Линия после заголовков
        doc.moveDown();
        const headerLineY = doc.y;
        doc.moveTo(tableLeft, headerLineY)
           .lineTo(tableLeft + colWidths.no + colWidths.product + colWidths.category + colWidths.sold + colWidths.revenue, headerLineY)
           .stroke();
        doc.moveDown(0.5);
        
        // Строки таблицы
        data.products.forEach((product: any, i: number) => {
          const rowTop = doc.y;
          const num = (i + 1).toString();
          const productName = product.name || t.product;
          const category = product.category?.name || (language === 'ru' ? 'Без категории' : 'No category');
          const sold = (product.salesCount || '0').toString();
          const revenue = `${(product.totalRevenue ? parseFloat(product.totalRevenue).toFixed(2) : '0.00')} ₽`;
          
          // Печатаем каждую ячейку в фиксированных позициях
          doc.text(num, tableLeft, rowTop);
          doc.text(productName, tableLeft + colWidths.no, rowTop, { width: colWidths.product - 5 });
          doc.text(category, tableLeft + colWidths.no + colWidths.product, rowTop, { width: colWidths.category - 5 });
          doc.text(sold, tableLeft + colWidths.no + colWidths.product + colWidths.category, rowTop);
          doc.text(revenue, tableLeft + colWidths.no + colWidths.product + colWidths.category + colWidths.sold, rowTop);
          
          // Вычисляем высоту, необходимую для этой строки
          const textHeight = Math.max(
            doc.heightOfString(productName, { width: colWidths.product - 5 }),
            doc.heightOfString(category, { width: colWidths.category - 5 }),
            12
          );
          doc.moveDown(textHeight / 12);
        });
        
        doc.moveDown();
      }
      
      // Нижний колонтитул документа
      doc.fontSize(9).text(t.footer, 50, doc.page.height - 50, {
        align: 'center',
        width: doc.page.width - 100
      });
      
      // Завершаем документ
      doc.end();
    } catch (error) {
      console.error('Ошибка при генерации PDF:', error);
      reject(error);
    }
  });
} 